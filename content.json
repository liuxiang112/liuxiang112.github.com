{"meta":{"title":"liuxiang","subtitle":null,"description":"liuxiang blog","author":"liuxiang","url":"https://liuxiang112.github.io"},"pages":[{"title":"","date":"2017-03-07T08:14:41.400Z","updated":"2016-11-08T07:20:00.000Z","comments":true,"path":"404.html","permalink":"https://liuxiang112.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2017-03-01T07:10:17.000Z","updated":"2017-03-07T13:58:49.742Z","comments":true,"path":"about/index.html","permalink":"https://liuxiang112.github.io/about/index.html","excerpt":"","text":"关于我正式从事了大半年的纯前端开发，使我对前端充满了热情喜爱和好奇，因为前端更贴近用户，可以直接看到各种炫酷的效果，还有它层出不穷的框架和极快的语言更新，我都很喜欢。性格比较开朗积极,能够与人很好相处,乐于跟团队打交道，有很强的团队精神; 学习能力与抗压能力都较强. 专业技能1234熟练使用html5 css3 javascript等各种技术进行产品的界面开发。熟练运用Photoshop、Sublime text、dreamweaver、fireworks等常用网页设计制作软件。能使用html5开发mobile app的界面和体验效果，并且能实现各种交互效果和兼容。对前端性能优化，用户体验，语义化有自己的简介和实战，能独立解决问题。 工作经历2015/11~2016/03 书众共赢科技有限公司 网络部（实习）负责协助前端工程师进行pc端网站的设计与实现,多数是静态页面的实现. 负责”同乡好运”网站的后期维护,调整. 获得最佳实习生奖. 同期工作之余开始系统性的自学web前端各项技术,接触移动端. 项目地址: http://www.txhaoyun.com 2016/05~2017/02 四川良木道门窗型材有限公司 web前端开发负责公司pc端和移动端官网，使用HTML5及CSS3对页面进行搭建，实现动画交互展现扁平化效果来向用户传递信息 根据产品需求分析并给出最优的网页前端结构解决方案并完成效果实现 利用css+html等将页面实现，高度还原设计图 用js、jQuery对页面原型进行布局搭建，并进行特效制作 技术实现：HTML5 CSS3 jQuery 项目收获：使用html5 css3特性对页面进行制作，效果显著；熟练原生javascript、jQuery的使用 项目地址:http://www.leawod.com http://m.leawod.com Social informationGitHub / 微博 /"},{"title":"categories","date":"2016-11-08T07:10:05.000Z","updated":"2016-11-08T07:52:20.000Z","comments":false,"path":"categories/index.html","permalink":"https://liuxiang112.github.io/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2016-11-08T07:10:37.000Z","updated":"2017-03-06T09:26:55.807Z","comments":false,"path":"schedule/index.html","permalink":"https://liuxiang112.github.io/schedule/index.html","excerpt":"","text":"school 2012 - 2016 电子科技大学成都学院 work 2015/11 - 2016/03 书众共赢科技有限公司"},{"title":"tags","date":"2016-11-08T07:10:28.000Z","updated":"2016-11-08T07:52:02.000Z","comments":false,"path":"tags/index.html","permalink":"https://liuxiang112.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入浅出js闭包","slug":"深入浅出js闭包","date":"2017-03-03T06:12:58.000Z","updated":"2017-03-08T07:48:55.518Z","comments":true,"path":"2017/03/03/深入浅出js闭包/","link":"","permalink":"https://liuxiang112.github.io/2017/03/03/深入浅出js闭包/","excerpt":"官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。读到这里，相信很多人都是一脸懵逼，因为描述的太学术。其实这句话通俗点说就是：JavaScript中的所有的function都是一个闭包。","text":"官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。读到这里，相信很多人都是一脸懵逼，因为描述的太学术。其实这句话通俗点说就是：JavaScript中的所有的function都是一个闭包。 一、变量的作用域要理解闭包，首先必须理解JavaScript特殊的变量作用域。其实变量的作用域无非就两种：全局变量和局部变量。 1234567891011121314151617 JavaScript语言的特殊之处就在于函数内部可以直接读取全局变量,如下例子： var n=100; function f1()&#123; alert(n); &#125; f1(); //100 另一方面，在函数外部无法读取函数内的局部变量，如下： function f1()&#123; var n=100; &#125; alert(n); //error这里有一个需要注意的地方：函数内部使用变量的时候，一定要用var声明，否则的话此变量实际上是一个全局变量！！！如下： function f1()&#123; n=100; &#125; alert(n); //100 二、如何从外部读取局部变量？因为一些原因，我们有时候需要得到函数内部的局部变量。但是在正常情况下，这是办不到的，所以我们不得不变通一下来实现。怎么变通呢？那就是在函数的内部再定义一个函数。 js代码 123456 function f1()&#123; n=100; function f2()&#123; alert(n); //100&#125; &#125; 在上面的代码中，函数f2就在函数f1的内部，这时f1内部的所有局部变量对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的“链式作用域”结构，子对象会一级一级向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以再f1外部读取它的内部变量了吗！代码如下： 123456789function f1()&#123; n=100; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); //100 三、闭包的概念上一节代码中的f2函数就是闭包。通过总结，我对它的理解就是：闭包就是能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取函数的局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。其中最大的用处有两个：一个是前面提到的可以读取函数内部的局部变量，另一个就是让这些变量的值始终保持在内存中。怎么理解这句话呢？请看下面的代码： 123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymousfunction），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意事项1由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（PublicMethod），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"js基础语法","slug":"js基础语法","permalink":"https://liuxiang112.github.io/categories/js基础语法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://liuxiang112.github.io/tags/javascript/"}]},{"title":"github本地环境搭建","slug":"github本地环境搭建","date":"2017-01-03T05:46:48.000Z","updated":"2017-01-03T05:51:18.000Z","comments":true,"path":"2017/01/03/github本地环境搭建/","link":"","permalink":"https://liuxiang112.github.io/2017/01/03/github本地环境搭建/","excerpt":"","text":"1、首先需要检查你电脑是否已经有 SSH key 12cd ~/.ssh ls 1ssh 2、创建一个 SSH key 1ssh-keygen -t rsa -C \"your_email@example.com\" 你github邮箱 中间一路敲回撤 会敲三次回车键 3、添加你的 SSH key 到 github上面去 4、测试一下该SSH key 1234567 ssh -T git@github.comThe authenticity of host 'github.com (207.97.227.239)' can't be established.# RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.# Are you sure you want to continue connecting (yes/no)?出现这些东西就可以了.","categories":[],"tags":[]},{"title":"web页面优化","slug":"web页面优化","date":"2016-12-27T08:06:53.000Z","updated":"2017-03-07T11:13:23.776Z","comments":true,"path":"2016/12/27/web页面优化/","link":"","permalink":"https://liuxiang112.github.io/2016/12/27/web页面优化/","excerpt":"作为一个web人，面试必定会遇到这个问题。 下面是从前端club分享上来的。 网页内容 减少http请求 减少dns查询次数 避免页面跳转 缓存ajax 延迟加载 提前加载 还少dom元素数量 根据域名划分内容 减少iframe 数量 避免404","text":"作为一个web人，面试必定会遇到这个问题。 下面是从前端club分享上来的。 网页内容 减少http请求 减少dns查询次数 避免页面跳转 缓存ajax 延迟加载 提前加载 还少dom元素数量 根据域名划分内容 减少iframe 数量 避免404 服务器 使用cdn 开启gzip压缩 配置etags 尽早flush 输出 使用ajax get请求 避免空图片src 添加expires或者cache-control报头文 cookie 减少cookie大小 页面内容是用无cookie域名 css 将样式表重置 避免css表达式 使用link replace @important 避免食用filters javascript 将脚本放在底部 使用外部的css and javsctipt文件 精简javasctipt and css 去除重复的脚本 减少dom访问 使用智能时间处理 images 优化图片 优化css sprite 不要在html汇总缩放图片 使用小且可缓存的favicon.ico 移动客户端 保持单个内容小于25kb 打包组建成符合文档 移动客户端","categories":[],"tags":[]},{"title":"html5移动端适配规则","slug":"html5移动端适配规则","date":"2016-11-22T02:08:20.000Z","updated":"2016-12-22T03:33:34.000Z","comments":true,"path":"2016/11/22/html5移动端适配规则/","link":"","permalink":"https://liuxiang112.github.io/2016/11/22/html5移动端适配规则/","excerpt":"移动端众多的手机型号使得前端开发起来 难度很大，所以，为了统一众多机型的适配，前端不得不采取大而全的方案去适配大多数屏幕。前端的解决方案也是简单而粗暴。通过缩放meta生成不同的缩放比例。还有一种是直接给根元素赋值大小。","text":"移动端众多的手机型号使得前端开发起来 难度很大，所以，为了统一众多机型的适配，前端不得不采取大而全的方案去适配大多数屏幕。前端的解决方案也是简单而粗暴。通过缩放meta生成不同的缩放比例。还有一种是直接给根元素赋值大小。 源码 普遍的适配 12345678910111213(function(doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window); 手淘的适配 12345678910111213! function() &#123; var e = \"@charset \\\"utf-8\\\";html&#123;color:#000;background:#fff;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%&#125;html *&#123;outline:0;-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0,0,0,0)&#125;html,body&#123;font-family:sans-serif&#125;body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,hr,button,article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section&#123;margin:0;padding:0&#125;input,select,textarea&#123;font-size:100%&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;fieldset,img&#123;border:0&#125;abbr,acronym&#123;border:0;font-variant:normal&#125;del&#123;text-decoration:line-through&#125;address,caption,cite,code,dfn,em,th,var&#123;font-style:normal;font-weight:500&#125;ol,ul&#123;list-style:none&#125;caption,th&#123;text-align:left&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;font-weight:500&#125;q:before,q:after&#123;content:''&#125;sub,sup&#123;font-size:75%;line-height:0;position:relative;vertical-align:baseline&#125;sup&#123;top:-.5em&#125;sub&#123;bottom:-.25em&#125;a:hover&#123;text-decoration:underline&#125;ins,a&#123;text-decoration:none&#125;\", d = document.createElement(\"style\"); if (document.getElementsByTagName(\"head\")[0].appendChild(d), d.styleSheet) &#123; d.styleSheet.disabled || (d.styleSheet.cssText = e) &#125; else &#123; try &#123; d.innerHTML = e &#125; catch (f) &#123; d.innerText = e &#125; &#125; &#125;(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758! function(N, M) &#123; function L() &#123; var a = I.getBoundingClientRect().width; a / F &gt; 540 &amp;&amp; (a = 540 * F); var d = a / 10; I.style.fontSize = d + \"px\", D.rem = N.rem = d &#125; var K, J = N.document, I = J.documentElement, H = J.querySelector('meta[name=\"viewport\"]'), G = J.querySelector('meta[name=\"flexible\"]'), F = 0, E = 0, D = M.flexible || (M.flexible = &#123;&#125;); if (H) &#123; console.warn(\"将根据已有的meta标签来设置缩放比例\"); var C = H.getAttribute(\"content\").match(/initial\\-scale=([\\d\\.]+)/); C &amp;&amp; (E = parseFloat(C[1]), F = parseInt(1 / E)) &#125; else &#123; if (G) &#123; var B = G.getAttribute(\"content\"); if (B) &#123; var A = B.match(/initial\\-dpr=([\\d\\.]+)/), z = B.match(/maximum\\-dpr=([\\d\\.]+)/); A &amp;&amp; (F = parseFloat(A[1]), E = parseFloat((1 / F).toFixed(2))), z &amp;&amp; (F = parseFloat(z[1]), E = parseFloat((1 / F).toFixed(2))) &#125; &#125; &#125; if (!F &amp;&amp; !E) &#123; var y = N.navigator.userAgent, x = (!!y.match(/android/gi), !!y.match(/iphone/gi)), w = x &amp;&amp; !!y.match(/OS 9_3/), v = N.devicePixelRatio; F = x &amp;&amp; !w ? v &gt;= 3 &amp;&amp; (!F || F &gt;= 3) ? 3 : v &gt;= 2 &amp;&amp; (!F || F &gt;= 2) ? 2 : 1 : 1, E = 1 / F &#125; if (I.setAttribute(\"data-dpr\", F), !H) &#123; if (H = J.createElement(\"meta\"), H.setAttribute(\"name\", \"viewport\"), H.setAttribute(\"content\", \"initial-scale=\" + E + \", maximum-scale=\" + E + \", minimum-scale=\" + E + \", user-scalable=no\"), I.firstElementChild) &#123; I.firstElementChild.appendChild(H) &#125; else &#123; var u = J.createElement(\"div\"); u.appendChild(H), J.write(u.innerHTML) &#125; &#125; N.addEventListener(\"resize\", function() &#123; clearTimeout(K), K = setTimeout(L, 300) &#125;, !1), N.addEventListener(\"pageshow\", function(b) &#123; b.persisted &amp;&amp; (clearTimeout(K), K = setTimeout(L, 300)) &#125;, !1), \"complete\" === J.readyState ? J.body.style.fontSize = 12 * F + \"px\" : J.addEventListener(\"DOMContentLoaded\", function() &#123; J.body.style.fontSize = 12 * F + \"px\" &#125;, !1), L(), D.dpr = N.dpr = F, D.refreshRem = L, D.rem2px = function(d) &#123; var c = parseFloat(d) * this.rem; return \"string\" == typeof d &amp;&amp; d.match(/rem$/) &amp;&amp; (c += \"px\"), c &#125;, D.px2rem = function(d) &#123; var c = parseFloat(d) / this.rem; return \"string\" == typeof d &amp;&amp; d.match(/px$/) &amp;&amp; (c += \"rem\"), c &#125; &#125;(window, window.lib || (window.lib = &#123;&#125;)); 说明 1 普遍的就是假设设计稿宽度为750px,转化为rem就是除以100px 2 淘宝的就是设计稿宽度为为750px,转化为rem就是除以75px 3 值得注意的是 淘宝的方案是不能默认设置meta缩放的。","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://liuxiang112.github.io/categories/Mobile/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://liuxiang112.github.io/tags/html5/"}]},{"title":"JavaScript中的prototype原型","slug":"JavaScript中的prototype原型","date":"2016-07-30T06:23:13.000Z","updated":"2016-09-27T07:39:12.000Z","comments":true,"path":"2016/07/30/JavaScript中的prototype原型/","link":"","permalink":"https://liuxiang112.github.io/2016/07/30/JavaScript中的prototype原型/","excerpt":"原型是什么 ？Function 类型有一个属性 prototype，直接翻译过来就是原型。这个属性就是一个指针，指向一个对象，这个对象包含一些属性和方法，这些属性和方法会被当前函数生成的所有实例（对象）所共享。这句话根据前面所说的，细细琢磨下来，就可以得到下面代码：","text":"原型是什么 ？Function 类型有一个属性 prototype，直接翻译过来就是原型。这个属性就是一个指针，指向一个对象，这个对象包含一些属性和方法，这些属性和方法会被当前函数生成的所有实例（对象）所共享。这句话根据前面所说的，细细琢磨下来，就可以得到下面代码： 123456789 function Person()&#123; ...&#125;Person.prototype = &#123; country : 'china', sayName : function()&#123; ... &#125;&#125; 先创建了一个 Function 类型的实例 person，然后 person 的方法 prototype 是一个对象，就声明指向了一个对象。这个对象里面的属性和方法，会被当前 person 函数生成的实例所共享。也就是说： 12person1 = new Person();person2 = new Person(); person1 和 person2 都是通过 Person 这个 Function 类型实例，再次生成的实例，它们俩都有共同的属性 country 和方法 sayName，因为它们都有某个指针（proto），直接指向 Person.prototype 所指向的对象。不过要注意 proto 这个指针是不标准的，只有 Chrome 和 Firefox 等浏览器自己定义的，实际中，也不会用到这个属性，只是作为理解 prototype 来用： 创建对象的模式 下面，我们就来看下创建对象的方法和常用模式，以及它们之间的优缺点。 1.工厂模式就像工厂一样，抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。通过使用函数代替部分重复工作，代码如下： 1234567891011function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"jiangshui\",\"22\",\"engineer\"); 这样就创建出来了一个人，工厂模式解决了多个相似对象重复创建问题，但是没有解决对象识别问题。只是单纯的创建了一个对象，而不管这个对象是从人类模版还是动物模版创建的，无法区分这个对象的类型。 2.构造函数模式创建一个自定义的构造函数，从而定义自定义对象类型的属性和方法。 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = jpb; this.sayName = function()&#123; alert(this.name); &#125;;&#125;;var person1 = new Person(...); 3.构造函数模式与工厂模式区别：没有显式的创建对象。直接将属性和方法赋值 this 对象。没有 return 语句。Person 是 Function 类型的对象，new 之后，会继续产生一个对象，但这个新产生的对象，由于在函数中传递进去参数，并赋值给了 this 指针，那么传递进去的内容，就变成了新产生对象的属性或方法。构造函数默认习惯是首字母大写，上面代码执行经历了下面几个步骤：创建一个新对象将构造函数作用域赋值给新对象执行构造函数中的代码返回新对象这样生成的实例中，都默认包含一个 constructor 属性指向构造函数，例如： 1alert(person1.constructor == Person); 所以用构造函数模式，有类型的区分，可以将它的实例标识为一种特定的类型。此外，构造函数就是普通的函数，因为要反馈得到新对象，所以用 new 来调用。如果不用的话，直接执行就跟普通函数一样，例如上面，执行 Person.sayName() 会弹出 window.name，因为函数在 window 下面执行，所以 this 指向 window。构造函数模式也是有缺陷的，构造函数模式里面的方法，在每个实例上都重新创建了一遍，因此不同实例上的同名函数是不相等的。例如： 1person1.sayName == person2.sayName; //false 也就是说，由构造函数生成的每个对象实例，属性和方法都是独有的，都是复制了一遍。属性独有是必须的，因为这正是对象之间不同的地方，但是很多方法功能和代码都是一样的，重复复制多次，显然就会浪费资源。所以我们可以把函数放在外面，然后在构造函数里面，用指针指向这个函数，那么生成的实例中，方法存储的就是一个指向某函数的指针，也就共用一个函数了： 12345678function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = sayName;&#125;function sayName()&#123; alert(this.name);&#125; 但是这样，这个函数就变成了全局函数，而且与 Person 构造函数关联性不强，没有封装性可言。下面有请原型模式登场。 原型模式前面已经介绍了一部分关于原型的基础知识。简单的说，就是每个函数都有一个 prototype 属性，指向一个对象（原型对象），这个对象里面可以放一些属性或者方法。然后这个函数生成的实例，会有一个不规范的属性（proto）指向原型。由此来看，你应该可以理解：prototype 产生的属性和方法是所有实例共享的。这样正好解决了上面构造函数模式中，实例中函数的共用问题。例如下面代码： 12345678910function Person()&#123; ....&#125;Person.prototype.name = \"jiangshui\";Person.prototype.sayName = function()&#123; alert(this.name);&#125;; var person1 = new Person();person1.sayName(); //jiangshui 或者1234567Person.prototype = &#123; constructor : Person, name : \"jiangshui\", sayName : function()&#123; alert(this.name); &#125;&#125;; 第二种方法覆盖了整个 prototype 对象，所以需要手动指定 constructor 属性，指向构造函数否则会指向 Object。梳理一下它们的关系：Person.prototype －》 原型对象，可以定义一些属性或者参数，被所有实例共用。Person.prototype.constructor == Person —》 原型对象有个默认的属性 constructor 指向该原型对象所属的构造函数（注意另一种写法会覆盖掉这个属性，需要重新指定）。person1 = new Person() －》构造函数生成实例，实例包含了构造函数的内容和原型对象的内容。person1.proto －》指向创建这个实例的原型对象（不规范，不要用）。使用 isPrototypeOf() 可以确定对象之间的关系。例如： 12Person.prototype.isPrototypeOf(person1); 当代码读取某个对象的某个属性，会执行搜索。先从当前对象开始，如果没有，则搜索指针指向的原型对象，而不会搜索构造函数。对象实例可以访问但是不能重写原型对象的值。如果实例中设置了与原型对象同名的属性，则搜索过程，在实例中结束而不会访问原型对象，所以达到覆盖的目的。因此即使这个属性设置为 null，也表示在实例中已经存在该属性，而不会取消掉这个属性，从而可以访问原型对应属性。所以需要使用 delete 操作符，完全删除实例属性，从而可以重新访问原型。原型是动态的，对原型对象所做的任何修改，都能立即从实例上反映出来。原因是实例与原型之间的松散链接关系，每次调用实例的属性方法，都会进行一次查询，如果原型变了，查询结果也就变了。了解原型之后，我们也可以对原生对象添加新方法或属性。Object、Array、String 等原生引用类型，与上面构造函数类似，我们可以用 prototype 扩充它们的方法。例如： 123456String.prototype.startsWith = function(text)&#123; return this.indexOf(text) == 0;&#125;;var msg = \"Hello World\";msg.startsWith(\"Hello\"); 这段代码为 String 这个原生引用类型，增加了一个 startsWith 方法，功能就是传递进去一个参数，看看要测试的字符串是否以参数开始。由于原型的动态性，所以只要执行一下，所有字符串类型的变量全都获得了这个方法。但是不推荐使用这个方法，如果用的太多，代码太多，会导致维护困难、代码混乱等情况。一般情况下，会先继承某个原生引用类型，然后再在新自定义的类型上创建。关于继承，后面会再总结。原型模式也不是万能的，原型中的所有属性和方法是被所有实例共享的，所以对于函数之类非常合适，而对于包含引用类型的属性来说，就会产生一些冲突。例如： 123456789function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, friends : [\"greg\",\"jack\"]&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"tom\");console.log(person2.friends); 你会在 console 中看到，person2 的 friends 多了一个 tom，这并不是我想要的，但是对 person1 定义他的朋友时，的确影响到了实例 person2。所以我们要结合原型模式和构造函数模式来使用。组合使用构造函数模式和原型模式这就是最常用的模式，构造函数用来定义实例属性，通过传递参数实现自定义；原型用来定义方法或者需要所有实例共享的属性。这样，既实现了自定义，又保证了共用，还避免了问题。12345678910111213function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"greg\",\"jack\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;;var jiangshui = new Person(\"jiangshui\",\"22\",\"engineer\"); ##实际应用示例 OK，到了这里，你可能会看懂原型是啥，以及如何创建对象，可是，这些又有什么用？确实，我之前的工作，一直也就是用 jQuery 写一些代码就可以了，根本用不到封装然后生成对象实现功能等。那这些究竟有什么用？这种开发方式主要用于模块化和组建化的开发。比如你常用的弹窗功能，你当然可以把弹窗有关代码，每次都粘贴复制，然后修改一下就可以用在项目里面了。更好的选择是把你的弹窗功能代码，抽象封装成这样的一个组件，这样当你需要用弹窗的时候，只需要传递参数生成一个弹窗实例，就可以调用了。 原型对象和原型链 在Javascript中，万物皆对象，但对象也有区别，大致可以分为两类，即：普通对象（Object）和函数对象（Function）。一般而言，通过new Function产生的对象是函数对象，其他对象都是普通对象。举例说明： 123456789101112131415161718192021function f1()&#123; //todo&#125;var f2 = function()&#123; //todo&#125;;var f3 = new Function('x','console.log(x)'); var o1 = &#123;&#125;;var o2 = new Object();var o3 = new f1(); console.log( typeof f1,//function typeof f2,//function typeof f3,//function typeof o1,//object typeof o2,//object typeof o3 //object);&gt;&gt; function function function object object object f1属于函数的声明，最常见的函数定义方式，f2实际上是一个匿名函数，把这个匿名函数赋值给了f2,属于函数表达式，f3不常见，但也是一种函数对象。Function是JS自带的对象，f1,f2在创建的时候，JS会自动通过new Function()的方式来构建这些对象，因此，这三个对象都是通过new Function()创建的。在Javascript中创建对象有两种方式：对象字面量和使用new表达式，o1和o2的创建恰好对应了这两种方式，重点讲一下o3, 如果用Java和C#的思路来理解的话，o3是f1的实例对象，o3和f1是同一类型，至少我以前这么认为，其实不然…那么怎么理解呢? 很简单，看o3是不是通过new Function产生的, 显然不是，既然不是函数对象，那就是普通对象 。通过对函数对象和普通对象的简单理解之后，我们再来了解一下Javascript中的原型和原型链：在JS中，每当创建一个函数对象f1 时，该对象中都会内置一些属性，其中包括prototype和proto, prototype即原型对象，它记录着f1的一些属性和方法。需要注意的是，prototype 对f1是不可见的，也就是说，f1不会查找prototype中的属性和方法。123function f()&#123;&#125;f.prototype.foo = \"abc\";console.log(f.foo); //undefined 那么，prototype有什么用呢？ 其实prototype的主要作用就是继承。 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。想要知道f1是如何把prototype留给“后代”，我们需要了解一下JS中的原型链，此时，JS中的 proto 入场了，这哥们长的很奇特，隐藏的也很深，以致于你经常见不到它，但它在普通对象和函数对象中都存在， 它的作用就是保存父类的prototype对象，JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的proto属性，这样，就形成了一代代传承… 1234function f()&#123;&#125;f.prototype.foo = \"abc\";var obj = new f();console.log(obj.foo); //abc bj对象拥有这样一个原型链以后，当obj.foo执行时，obj会先查找自身是否有该属性，但不会查找自己的prototype,当找不到foo时，obj就沿着原型链依次去查找…在上面的例子中，我们在f的prototype上定义了foo属性，这时obj就会在原型链上找到这个属性并执行。本博客摘抄自脚本之家","categories":[{"name":"js基础语法","slug":"js基础语法","permalink":"https://liuxiang112.github.io/categories/js基础语法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://liuxiang112.github.io/tags/javascript/"}]},{"title":"使用github hexo搭建免费博客","slug":"hexo搭建免费博客","date":"2016-07-30T06:12:58.000Z","updated":"2017-03-06T09:01:32.496Z","comments":true,"path":"2016/07/30/hexo搭建免费博客/","link":"","permalink":"https://liuxiang112.github.io/2016/07/30/hexo搭建免费博客/","excerpt":"本片博文主要介绍如何使用github来搭建一个免费的个人博客:借助github可以搭建免费的博客，所以有了liuxiang’blog,希望给想要搭建免费的博客的你一个参考。","text":"本片博文主要介绍如何使用github来搭建一个免费的个人博客:借助github可以搭建免费的博客，所以有了liuxiang’blog,希望给想要搭建免费的博客的你一个参考。 Start hexo development of the road —开始hexo的开发之路 开发node npm git 必备的开发环境 node官网下载 安装node 自带npm 无需下载 git直接百度下载 下载完成之后，进入cmd 输入以下命令 12node--version // 会显示node版本npm--version // 会显示npm版本 node在win7 win8 win10的安装有时候会出问题 请自行百度 hexo next 安装基于node的hexo框架 还有next主题 hexo安装123456789 $ npm install -g hexo // 全局安装hexo$ cd 进入你的站点下面 执行 hexo init //完成初始化$ hexo generate 生成静态页面$ hexo server 本地启动出现下面两条日志 项目已经启动INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. next安装 12$ cd yousite$ git clone https://github.com***next next配置 12$ 进入站点 找到 _config.yml$ theme: next // landscape默认 部署阶段 配置Github github账户 注册 github 登陆 配置ssh并add到github账户的ssh下 123456789ls -al ~/.ssh 查看本地ssh 如果没有ssh-keygen -t rsa -C \"angelen10@163.com\" 邮箱是你注册github的邮箱查看本地电脑已经生成ssh //C:\\Users\\linda\\.ssh里面有一个id_rsa.pub 用编辑器打开 复制到gitssh上去ssh -T git@github.com Hi linda! You've successfully authenticated, but GitHub does not provide shell access. 表示成功 配置_config.yml 123456789101112131415161718192021222324title: liuxiang // 修改为自己的title（随意就好）subtitle: // 导航上面的小标题description: liuxiang blog // 描述author: liuxianglanguage: entimezone:url: https://liuxiang112.github.io // 修改自己的 就是域名root: /permalink: :year/:month/:day/:title/permalink_defaults:theme: next // 主题deploy:type: gitrepository: git@github.com:***/**.github.io.git 其他的都不要动 我为什么弄成git 而不是github 我电脑报错 解决方案如下deploy的type改成git，然后运行下npm install hexo-deployer-git --save 再hexo g hexo d这也是百度的答案 新建文章 新建单页 123456789101112hexo new\"postName\" #新建文章hexo new page\"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo help # 查看帮助hexo version #查看Hexo的版本以下是简写hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 发布 每次发布就这几条命令. 1234hexo clean //清除hexo generate //生成静态页面hexo deploy //发布 min版的hexo开发模式/ 安装node 确保正确安装 / 进入系统盘 建立一个文件 我们叫做demo / cd demo / 执行 npm install -g hexo / 执行 hexo init / 执行 hexo g / 执行 hexo s / 以上步骤确保执行 项目就可以跑起来/","categories":[{"name":"免费博客","slug":"免费博客","permalink":"https://liuxiang112.github.io/categories/免费博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuxiang112.github.io/tags/hexo/"}]},{"title":"js特效动画之切换","slug":"js特效动画之切换","date":"2015-12-22T02:30:44.000Z","updated":"2016-12-22T03:33:40.000Z","comments":true,"path":"2015/12/22/js特效动画之切换/","link":"","permalink":"https://liuxiang112.github.io/2015/12/22/js特效动画之切换/","excerpt":"大量的网站,app,微信公众号等都离不开一个常用的特效动画。就是切换。个人感觉切换也是很好的一个交互行为。今天，就用原生实现javascript切换，同时也提供jquery版的切换。","text":"大量的网站,app,微信公众号等都离不开一个常用的特效动画。就是切换。个人感觉切换也是很好的一个交互行为。今天，就用原生实现javascript切换，同时也提供jquery版的切换。 源码 html通用 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;tab slide &lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;nav id=\"nav\"&gt; &lt;ul&gt; &lt;li class=\"active\"&gt;site&lt;/li&gt; &lt;li&gt;engineers&lt;/li&gt; &lt;li&gt;imacos&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;article id=\"article\"&gt; &lt;p style=\"display:block\"&gt;Welcome you visit my site&lt;/p&gt; &lt;p&gt;I am a web front-end development engineers&lt;/p&gt; &lt;p&gt;windows8 / imacos / ubuntu / centos&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; javasctipt 123456789101112131415161718192021222324252627282930313233343536373839404142 window.onload = function() &#123; slide('nav', 'article'); &#125;function slide(ida, idb) &#123; var lis = document.getElementById(ida).getElementsByTagName('li') var divs = document.getElementById(idb).getElementsByTagName('p') if (lis.length != divs.length) &#123; return; &#125;; for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].id = i; // onclick onmouseover lis[i].onclick = function(e) &#123; for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = ''; divs[j].style.display = 'none'; &#125; this.className = 'active'; divs[this.id].style.display = 'block'; event.stopPropagation(); &#125; &#125;&#125; jquery 1234567891011121314151617181920212223242526272829303132333435363738394041424344$(document).on('ready', function() &#123; slide('nav', 'article'); &#125;)function slide(ida, idb) &#123; var lis = $('#' + ida).find('li'); var divs = $('#' + idb).find('p'); if (lis.length != divs.length) &#123; return; &#125;; for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].id = i; // onclick mouseover lis[i].onclick = function(e) &#123; for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = ''; divs[j].style.display = 'none'; &#125; this.className = 'active'; divs[this.id].style.display = 'block'; event.stopPropagation(); &#125; &#125;&#125; 说明 支持点击 鼠标滑过时间 遵守slide函数参数的准确性 每一个导航元素有赋值id","categories":[],"tags":[]}]}